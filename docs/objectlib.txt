Object Library
==============

MAIN FEATURES
-------------

* Key/value object storage manager
  Create objects with dynamic content. Data is internally stored in ADT Arrays.

  Object data can be accessed through get/set functions (which implies
  validation).

* Mutable or immutable objects
  Objects can be either mutable or immutable. Immutable objects can't modify
  their type (add/remove keys) when created, but data in existing keys can be
  modified.

  Both use a type descriptor as a template. Mutable objects store a bundled
  descriptor so they can be modified independently, while immutable objects
  store a reference to a shared read-only type descriptor to save memory.

* Supports built-in and custom data validation
  The library supports basic validation constraints such as min/max limits in
  addition to a callback where the user can do custom validation of the object.

* Type safe (as far as it's possible in SourcePawn)
  Each key is assigned a type. This structure requires you to use appropriate
  get/set functions where the library will check if you use the correct
  function at runtime - and the compiler will be able to do tag checks.

* Import (and validate) data from Valve's KeyValue file format
  Creates objects based on the contents of a KeyValue file, and a user defined
  object type descriptor with optional validation constraints.
  
  TO BE IMPLEMENTED. (Probably as a separate library that depend on this one.)

* Reflection
  Objects or types can be inspected at run time. Loop through keys, get data
  types or validation constraints.


WHY USE THIS
------------

This is an alternative to enumerated arrays. If you use various types of data
sets, such as player profiles or weapon profiles, you don't have to create
specific storage implementation for each data set when using this library. You
just need to define types and create objects.

If you have many data sets, a "hard coded" manual solution for each set will
result in somewhat repeated code.

If you also have validation constraints, that code will be repeated too.

This library will help you with everything from reading keyvalue files to
storage and validation. You just need to declare types and validation
constraints and the library will enforce it.


WHAT IT DOESN'T DO
------------------

* Memory management
  You'll have to make sure objects and types are deleted when no longer in use.
  Otherwise there will be memory leaks. Read the API documentation carefully
  to see which functions that return resources that must be released again.
  (Hint: Cloning or creating objects and types)

* It's not a tree structure
  Regular KeyValue files use a tree structure. This object manager use a plain
  associative array structure where each object has keys mapped to values.

  However, a tree structure is indirectly supported by linking object references
  together. Objects can store references to other objects. It has its own object
  data type so that the compiler can do tag checking on object references as
  well.


RESOURCE USAGE
--------------

* Small CPU overhead
  The main goal isn't a super efficient object manager, but efficient enough.
  Because of type checking and validation there is a small overhead when
  modifying data. These checks are basically comparison of primitive values and
  shouldn't be an issue with normal usage.

  Another overhead is the native call overhead for reading and writing to ADT
  arrays. This overhead is so tiny it shouldn't be mentioned, but it's still
  there. Remember that just because something is _slower_ doesn't mean it's
  slow.

  If you have code that's _very_ busy you should consider using buffers or
  caches in front of the data storage. Use the SourceMod profiler to measure if
  this really is an issue in your code - before optimizing.

* Memory overhead
  Since it's a dynamic storage manager, objects need to store meta data and will
  use a little bit more memory than a static hard coded solution would. But it's
  also a lot more flexible solution.

  However, immutable objects are more memory efficient than mutable objects,
  since immutable objects share their type descriptor between objects of the
  same type. Mutable objects have their own private type descriptor.
  
  Use immutable objects when you can to reduce memory overhead, especially on
  object types that aren't modified after creation.
  
  The memory overhead also depends on how much space you reserve for each value
  entry. Memory will be wasted if you reserve more space than the longest value
  requires.
  
  An object with 4 strings of 256 byte will require about 2 KB, including the
  object array itself, list of null keys and a type descriptor reference.
  
  The type descriptor for this object use 8-9 KB where the trie (key name index)
  use 8 KB alone.

* A little memory and CPU overhead is a trade off for writing more code
  yourself. It can still be efficient if used correctly.


How to Create and Use Objects
=============================

Also see the complete example in ImmutableObjectExample in objectlibtest.sp.


DECLARING TYPES
---------------

Types are a composite of key names and their data types, which is stored in a
type descriptor.

Create a type descriptor by using the ObjLib_CreateType function. Then use
ObjLib_AddKey to add keys to the type:

    // Declare a "person" type.
    new ObjectType:personType = ObjLib_CreateType();
    ObjLib_AddKey(personType, "name", ObjDataType_String);
    ObjLib_AddKey(personType, "skillPoints", ObjDataType_Cell);
    ObjLib_AddKey(personType, "bestFriend", ObjDataType_Object);

This type descriptor can be used as a template to create "person" objects.
Immutable objects will use this type descriptor directly, while mutable objects
will clone and use a private one.

When you create an immutable object with this type, the type descriptor will be
locked. You can still create more objects based on it, but keys cannot be added
or removed unless you create mutable object or clone the type into a separate
unlocked type.


CREATING OBJECTS
----------------

There are two types of objects: Mutable and immutable. Mutable objects allow you
to add or remove keys after they were created, while immutable objects only
allow the data in existing keys to be modified.

The most optimal solution is to use immutable objects when you can because to
reduce memory overhead.

Create objects using the ObjLib_CreateObject function and specify which type of
object you're creating. Also set mutableObject to false if you're creating an
immutable object:

    // Create immutable person objects.
    new Object:alice = ObjLib_CreateObject(personType, false);
    new Object:bob = ObjLib_CreateObject(personType, false);

Now there's two person objects with the keys described in the person type
descriptor. Simply use the set functions to initialize object data:

    // Setting values.
    ObjLib_SetString(alice, "name", "Alice");
    ObjLib_SetCell(alice, "skillPoints", 100);
    ObjLib_SetObject(alice, "bestFriend", bob);
    
    // Retrieving values.
    new skillPoints = ObjLib_GetCell(alice, "skillPoints");

Note the use of functions that match the data type for each key. If there's a
mismatch the compiler will probably first warn about a tag mismatch, and if not,
the object library will detect a type mismatch at runtime and throw an error.
This pattern is chosen to enforce type safety as far as SourcePawn can do.

There are also functions for refering keys by index instead of names (like
ObjLib_SetCellAt) so that it's possible to do optimizations in busy code such as
loops. You retreive key indexes by using ObjLib_GetKeyIndex and cache them.
Otherwise the object library is using ADT tries to map key names to indexes for
fast lookup.


CLONING TYPES AND OBJECTS
-------------------------

When a type is used to create an immutable objects, it's locked. But it can be
cloned to a separate type so you can continue modifying it.

Cloning objects need special treatment about the type descriptor (which is
handled internally by the object library). It's important to know about this so
that memory management can be done properly. There's one special case.


AVOID MEMORY LEAK WHEN CLONING FROM MUTABLE TO IMMUTABLE OBJECT

Cloning a mutable object into an immutable object will create a clone of the
type descriptor. The cloned object is using it, but the cloned type is not
attached to anything since it's locked and can be shared between multiple
objects.

Delete this cloned type when it's no longer in use by any object. It can be
retrieved from the cloned object by using ObjLib_GetTypeDescriptor. If you
delete the cloned immutable object without deleting the cloned type, there will
be a memory leak.

Example with leak:

    new Object:mutableObject = ...      // some mutable object.
    new Object:immutableObject = ObjLib_CloneObject(mutableObject, false);
    
    ObjLib_DeleteObject(immutableObject);
    
    // INVISIBLE LEAK!
    // There was a type descriptor cloned behind the scenes and we've lost the
    // reference to it.

How to properly handle this:

    new Object:mutableObject = ...      // some mutable object.
    new Object:immutableObject = ObjLib_CloneObject(mutableObject, false);
    
    new ObjectType:typeFromImmutableObject = ObjLib_GetTypeDescriptor(immutableObject);
    ObjLib_DeleteObject(immutableObject);
    ObjLib_DeleteObjectType(typeFromImmutableObject);   // Deleting hidden cloned type.


ERROR HANDLERS
--------------

Type descriptors may store a custom error handler for handling recoverable
errors. Unrecoverable errors are always handled by such as invalid object
references. Recoverable errors are invalid key names, type mismatch and
constraint violation.

The error handler use the ObjLib_ErrorHandler callback and may be used when
creating type descriptors.

It's also possible to override an error handler in data accessor functions such
as ObjLib_SetCell. Then it's possible to use custom error handlers in various
situations.

Possible future improvements:
Custom error handler for individual keys or constraints. Need to consider
whether this is actually useful and how to implement this.


VALIDATION
----------

Validation can be applied to keys by assigning a constraint object to it when
adding keys. These objects can be created by using the constraint object
builders. The following builders are available:

    * ObjLib_GetCellConstraints
    * ObjLib_GetFloatConstraints
    * ObjLib_GetHandleConstraints
    * ObjLib_GetFunctionConstraints
    * ObjLib_GetStringConstraints
    * ObjLib_GetArrayConstraints
    * ObjLib_GetObjectConstraints
    * ObjLib_GetObjTypeConstraints
    * ObjLib_GetCustomConstraints   - Can be used with any data type.

The constraint object used must match the data type of the key.

A custom constraint object may be used to let the user decide which values that
are valid. It contains a reference to a ObjLib_KeyValidator callback.

If a value violated a constraint the error handler will trigger a constraint
violation error where the user is able to handle it. The value is rejected.


DELETING CONSTRAINT OBJECTS

Constraint objects should only be deleted manually if it's not used anywhere.
When attached to keys the type descriptor will delete constraint objects when
it's deleted itself.


EXAMPLE USAGE

    // Declare a "person" type.
    new ObjectType:personType = ObjLib_CreateType();
    
    // Get name constraints. We only set "nonempty" in this example to prevent
    // empty strings. The builder has a lot of other optinal parameters too.
    new Object:nameConstraints = ObjLib_GetStringConstraints(true);
    
    // Get skill constraints. Block negative values.
    new Object:skillConstraints = ObjLib_GetCellConstraints(
            false,          // nonzero
            true,           // lowerLimit
            false,          // upperLimit
            0);             // min
    
    // Get friend constraints. Only allow personType objects.
    new Object:friendConstraints = ObjLib_GetObjectConstraints(
            false,          // nonzero
            personType);    // type
    
    // Add keys to person type and assign constraint objects.
    ObjLib_AddKey(personType, "name", ObjDataType_String, nameConstraints);
    ObjLib_AddKey(personType, "skillPoints", ObjDataType_Cell, skillConstraints);
    ObjLib_AddKey(personType, "bestFriend", ObjDataType_Object, friendConstraints);
    
    // Trying to set skillPoints to -1 will trigger a constraint violation
    // error.
    ObjLib_SetCell(somePersonObject, "skillPoints", -1);


MEMORY MANAGEMENT
-----------------

When objects or types are no longer used they must be deleted, or there will be
memory leaks.

    ObjLib_DeleteObject(alice);
    ObjLib_DeleteObject(bob);
    ObjLib_DeleteType(personType);

These functions will by default also reset the references to INVALID_OBJECT or
INVALID_OBJECT_TYPE.

Make sure that you don't delete a type that's still used by other objects. If
those objects try to access their type descriptor there will be an error.

Mutable objects that have their own private type descriptors will delete them
itself. Trying to delete their type descriptor will trigger an error because
they're attatched to an object.


REFLECTION
----------

Since everything is declared at run time, it's also possible to inspect object
meta data. Here's an example that will get the list of keys and their data
types:

    // Reflection. List data types for each key in personType.
    new Handle:keys = ObjLib_GetTypeKeys(personType);
    new Handle:dataTypes = ObjLib_GetTypeDataTypes(personType);
    new len = GetArraySize(keys);
    
    PrintToServer("Keys in personType");
    for (new i = 0; i < len; i ++)
    {
        // Get key name.
        GetArrayString(keys, i, buffer, sizeof(buffer));
        
        // Get data type string.
        ObjLib_DataTypeToString(ObjectDataType:GetArrayCell(dataTypes, i), buffer2, sizeof(buffer2));
        
        PrintToServer("%s: %s", buffer, buffer2);
    }


KEYVALUE PARSER
---------------

TODO: Rewrite notes into full text.

Parsing:
* A KV section loaded into an object.
* Sub sections are parsed into another object. The super section store the
  object reference.
* Two parse modes:
    - List mode. Assumes every key in the root section is a sub section. Each
      section is parsed into an object. The object reference is added to a list.
    - Object mode. The root itself is parsed into an object.
* Using recursion when parsing sections.
* Delegate reading and storing into objects to a separate handler. The parse
  function should only do traversal and get key names. The rest is taken care of
  in the handler.

Validation:
* Sometimes data cannot be validated until all keys are parsed. Provide a
  callback for doing full object validation once a section is parsed.
  How to handle nested sections?
* Keep track of cursor location (stack of key names). If a parse error occour
  use the stack to build a path to the current location.

Type checking:
* Match KV file against predefined type descriptor (eventually with nested types
  for sub sections in KV files.
* Eventually support references where the KV file store a name (string) of an
  object. While parsing, this string is replaced by a direct object reference.
  We already have the Object data type. The parser only need to check
  constraints on that key to see if a certain object type is required. If there
  is a type restriction, it could read the name from the KV file and pass it to
  an external lookup callback handled by the user. If the lookup failed the
  parser will repsond with an error.
* Ignore, but warn about undefined keys.

Type builder:
* Build a type descriptor while parsing.
* Data type would be string on all keys. Sections will be stored as object
  references.

How to loop through keys and get both key name and value:
http://code.google.com/p/zombiereloaded/source/browse/src/zr/modules/gamerules.inc?repo=zr-dev-base#355


PARSE METHOD:

Object:ParseInObjectMode(typeDescriptor, sectionKeyName)
{
    load kv file
    rewind
    
    if (typeDescriptor)
    {
        ParseSectionAs(kv, typeDescriptor, sectionKeyName)
        set object
    }
    else
    {
        ParseSection(kv, sectionKeyName)
        set object
    }
}

Handle:ParseInListMode(typeDescriptor, sectionKeyName)
{
    load kv file
    rewind
    
    create list
    
    for(each section in root)
    {
        if (typeDescriptor)
        {
            ParseSectionAs(kv, typeDescriptor, sectionKeyName)
            add object to list
        }
        else
        {
            ParseSection(kv, sectionKeyName)
            add object to list
        }
    }
    
    return list
}

ParseSection(kv, sectionKeyName)
{
    create mutable object
    
    store section name in sectionKeyName
    
    for (each key in kv section)
    {
        if (key is section)
        {
            ParseSection()
            set object
        }
        else
        {
            add key, data type: string, no constraints
            set string value
        }
    }
    
    return object
}

ParseSectionAs(kv, sectionKeyName, typeDescriptor)
{
    create immutable object, use type passed to parse object function
    
    store section name in sectionKeyName
    
    for (each key in KV section)
    {
        if (key defined in type)
        {
            if (key is section)
            {
                get type, as defined in type descriptor for this key
                ParseSectionAs(type)
                set object
            }
            else
            {
                add key to object   // implies validation if there are constraints
            }
        }
        else
        {
            warn about unexpected key (use callback from type)
        }
    }
    
    return object
}


API
---

TODO: This is getting outdated. Reorganize and update signatures and comments.
      Move to objectlib-api.txt.

List of public functions in the object library:

stock ObjectType:ObjLib_CreateType(blockSize = 1, keySzie = 8)
stock ObjLib_DeleteType(&ObjectType:typeDescriptor, bool:resetReference = true)
stock ObjectType:ObjLib_CloneType(ObjectType:typeDescriptor, bool:locked = false)
stock bool:ObjLib_IsValidObjectType(ObjectType:typeDescriptor)
stock ObjLib_AddKey(ObjectType:typeDescriptor, const String:keyName[], ObjectDataType:dataType = ObjDataType_Any)
stock bool:ObjLib_RemoveKey(ObjectType:typeDescriptor, const String:keyName[])
stock bool:ObjLib_KeyExist(ObjectType:typeDescriptor, const String:keyName[])
stock bool:ObjLib_AddObjectKey(Object:object, const String:keyName[], ObjectDataType:dataType = ObjDataType_Any)
stock ObjLib_RemoveObjectKey(Object:object, const String:keyName[])
stock Object:ObjLib_CreateObject(ObjectType:typeTemplate, bool:mutableObject = true)
stock ObjLib_DeleteObject(&Object:object, resetReference = true)
stock Object:ObjLib_CloneObject(Object:objectTemplate, bool:mutableObject = true, bool:cloneHandles = false)
stock bool:ObjLib_IsValidObject(Object:object)
stock bool:ObjLib_IsMutable(Object:object)
stock any:ObjLib_GetAny(Object:object, const String:keyName[])
stock ObjLib_SetAny(Object:object, const String:keyName[], any:value)
stock ObjLib_GetCell(Object:object, const String:keyName[])
stock ObjLib_SetCell(Object:object, const String:keyName[], any:value)
stock bool:ObjLib_GetBool(Object:object, const String:keyName[])
stock ObjLib_SetBool(Object:object, const String:keyName[], bool:value)
stock Float:ObjLib_GetFloat(Object:object, const String:keyName[])
stock ObjLib_SetFloat(Object:object, const String:keyName[], Float:value)
stock Handle:ObjLib_GetHandle(Object:object, const String:keyName[])
stock ObjLib_SetHandle(Object:object, const String:keyName[], Handle:value)
stock Function:ObjLib_GetFunction(Object:object, const String:keyName[])
stock ObjLib_SetFunction(Object:object, const String:keyName[], Function:value)
stock ObjLib_GetArray(Object:object, const String:keyName[], any:buffer[], maxlen)
stock ObjLib_SetArray(Object:object, const String:keyName[], const any:values[], maxlen)
stock ObjLib_GetString(Object:object, const String:keyName[], String:buffer[], maxlen)
stock ObjLib_SetString(Object:object, const String:keyName[], const String:value[])
stock Object:ObjLib_GetObject(Object:object, const String:keyName[])
stock ObjLib_SetObject(Object:object, const String:keyName[], Object:value)
stock ObjectType:ObjLib_GetObjectType(Object:object, const String:keyName[])
stock ObjLib_SetObjectType(Object:object, const String:keyName[], ObjectType:value)
stock any:ObjLib_GetAnyAt(Object:object, index)
stock ObjLib_SetAnyAt(Object:object, index, any:value)
stock ObjLib_GetCellAt(Object:object, index)
stock ObjLib_SetCellAt(Object:object, index, value)
stock bool:ObjLib_GetBoolAt(Object:object, index)
stock ObjLib_SetBoolAt(Object:object, index, bool:value)
stock Float:ObjLib_GetFloatAt(Object:object, index)
stock ObjLib_SetFloatAt(Object:object, index, Float:value)
stock Handle:ObjLib_GetHandleAt(Object:object, index)
stock ObjLib_SetHandleAt(Object:object, index, Handle:value)
stock Function:ObjLib_GetFunctionAt(Object:object, index)
stock ObjLib_SetFunctionAt(Object:object, index, Function:value)
stock ObjLib_GetArrayAt(Object:object, index, any:buffer[], maxlen)
stock ObjLib_SetArrayAt(Object:object, index, const any:values[], maxlen)
stock ObjLib_GetStringAt(Object:object, index, String:buffer[], maxlen)
stock ObjLib_SetStringAt(Object:object, index, const String:value[])
stock Object:ObjLib_GetObjectAt(Object:object, index)
stock ObjLib_SetObjectAt(Object:object, index, Object:value)
stock ObjectType:ObjLib_GetObjectTypeAt(Object:object, index)
stock ObjLib_SetObjectTypeAt(Object:object, index, ObjectType:value)
stock ObjectType:ObjLib_GetTypeDescriptor(Object:object)
stock ObjLib_GetKeyIndex(Object:object, const String:keyName[])
stock bool:ObjLib_IsTypeMutable(ObjectType:typeDescriptor)
stock ObjLib_DataTypeToString(ObjectDataType:dataType, String:buffer[], maxlen)
stock Handle:ObjLib_GetTypeKeys(ObjectType:typeDescriptor)
stock Handle:ObjLib_GetTypeDataTypes(ObjectType:typeDescriptor)

________________________________________________________________________________
/**
 * Object tag.
 */
enum Object
{
    INVALID_OBJECT = 0
}

/**
 * Number of bytes reserved for key names.
 */
#define OBJECT_KEY_NAME_LEN     32

/**
 * Object type descriptor tag.
 */
enum ObjectType
{
    INVALID_OBJECT_TYPE = 0
}

/**
 * Data types that objects can store.
 */
enum ObjectDataType
{
    ObjDataType_Any,            /** Does not include arrays. */
    ObjDataType_Cell,
    ObjDataType_Bool,
    ObjDataType_Float,
    ObjDataType_Handle,
    ObjDataType_Function,
    ObjDataType_Array,
    ObjDataType_String,
    ObjDataType_Object,
    ObjDataType_ObjectType,
}

________________________________________________________________________________
/**
 * Creates an empty object type descriptor.
 *
 * Note: You may use ByteCountToCells to calculate number of cells required to
 *       fit a certain string length for blockSize and keySize.
 *
 * @param blockSize     (Optional) Maximum number of cells reserved for each
 *                      value entry. Default is 1 cell.
 * @param keySize       (Optional) Maximum number of cells reserved for each
 *                      key name. Default is 8 cells (32 bytes/characters).
 *
 * @return              Reference to type descriptor. Must be deleted with
 *                      ObjLib_DeleteType when no longer in use.
 *
 *                      Note: Don't delete type descriptors if there are objects
 *                      using it. Delete objects first.
 */
stock ObjectType:ObjLib_CreateType(blockSize = 1, keySzie = 8)

________________________________________________________________________________
/**
 * Deletes an object type descriptor.
 *
 * Warning: If there are objects refering to this type descriptor they may
 *          trigger an error when trying to use it. Delete objects first.
 *
 * @param typeDescriptor    Type descriptor to delete.
 * @param resetReference    (Optional) Reset typeDescriptor to
 *                          INVALID_OBJECT_TYPE when deleted. Default is true.
 */
stock ObjLib_DeleteType(&ObjectType:typeDescriptor, bool:resetReference = true)

________________________________________________________________________________
/**
 * Creates a new object type based on the specified type descriptor.
 *
 * Note: blockSize and keySize of the new cloned object type cannot be modified.
 * Note: The new object type will not be attatched to an object.
 *
 * @param typeDescriptor    Source object type template.
 * @param locked            (Optional) Whether the new object type is locked.
 *                          Default is false.
 *
 * @return                  New object type descriptor. Must be deleted with
 *                          ObjLib_DeleteType when no longer in use.
 */
stock ObjectType:ObjLib_CloneType(ObjectType:typeDescriptor, bool:locked = false)

________________________________________________________________________________
/**
 * Returns whether the object type descriptor is valid.
 *
 * @param typeDescriptor    Type descriptor to validate.
 *
 * @return                  True if valid, false otherwise.
 */
stock bool:ObjLib_IsValidObjectType(ObjectType:typeDescriptor)

________________________________________________________________________________
/**
 * Adds a new key to an object type descriptor.
 * 
 * @param typeDescriptor    Handle to type descriptor.
 * @param keyName           Name of the new key. Case sensitive.
 * @param dataType          Data type of key.
 */
stock ObjLib_AddKey(ObjectType:typeDescriptor, const String:keyName[], ObjectDataType:dataType = ObjDataType_Any)

________________________________________________________________________________
/**
 * Removes a key from an object type descriptor, if not locked.
 *
 * @param typeDescriptor    Object type descriptor to remove key from.
 * @param keyName           Name of key to remove. Case sensitive.
 *
 * @return                  True if successful, false if type descriptor was
 *                          locked.
 */
stock bool:ObjLib_RemoveKey(ObjectType:typeDescriptor, const String:keyName[])

________________________________________________________________________________
/**
 * Returns whether a key exist in an object type descriptor.
 *
 * @param typeDescriptor    Obect type descriptor to inspect.
 * @param keyName           Key to search for. Case sensitive.
 *
 * @return                  True if found, false otherwise.
 */
stock bool:ObjLib_KeyExist(ObjectType:typeDescriptor, const String:keyName[])

________________________________________________________________________________
/**
 * Adds a new key to an object, if not locked.
 *
 * @param object    Object to remove key from.
 * @param keyName   Name of key to remove. Case sensitive.
 * @param dataType  Data type of key.
 */
stock bool:ObjLib_AddObjectKey(Object:object, const String:keyName[], ObjectDataType:dataType = ObjDataType_Any)

________________________________________________________________________________
/**
 * Removes a key from an object, if not locked.
 *
 * Warning: Data associated with this key will also be deleted.
 *
 * @param object    Object to remove key from.
 * @param keyName   Name of key to remove. Case sensitive.
 */
stock ObjLib_RemoveObjectKey(Object:object, const String:keyName[])

________________________________________________________________________________
/**
 * Creates an empty object based on the type template.
 *
 * There are two types of objects, mutable and immutable.
 *
 * Mutable objects store their own copy of the type descriptor when created so
 * that keys can be added or removed. They use a bit more memory because of
 * this, but are flexible.
 *
 * Immutable objects can have its contents modified, but not its type. Keys
 * cannot be added or removed. The type template is used directly and shared
 * between immutable objects. Memory usage is more efficient than mutable
 * objects.
 *
 * Warning:
 * Creating an immutable object will automatically lock the type template
 * because it's now used directly. If you don't want to lock it, clone it with
 * ObjLib_CloneType and use the cloned type template instead.
 *
 * @param typeTemplate      Object type to use.
 * @param mutableObject     (Optional) Whether the object is mutable (add/remove
 *                          keys). Default is true.
 *
 * @return                  Reference to new object. Must be deleted with
 *                          ObjLib_DeleteObject when no longer in use.
 */
stock Object:ObjLib_CreateObject(ObjectType:typeTemplate, bool:mutableObject = true)

________________________________________________________________________________
/**
 * Deletes an object and its data.
 *
 * @param object            Object to delete.
 * @param resetReference    (Optional) Reset object to INVALID_OBJECT when
 *                          deleted. Default is true.
 */
stock ObjLib_DeleteObject(&Object:object, resetReference = true)

________________________________________________________________________________
/**
 * Creates a clone of an object and its data.
 *
 * Note: If the object data contain reference values, only the references
 *       themself will be cloned, not the data they refer to. See the
 *       cloneHandles parameter for more info.
 *
 * Warning: Creating an immutable object from a mutable object will also create
 *          a clone of the source type descriptor. Delete this type descriptor 
 *          when it's no longer in use. It can be retrieved from the cloned
 *          object with ObjLib_GetTypeDescriptor.
 *
 * @param objectTemplate    Source object.
 * @param mutableObject     (Optional) Make new object mutable. Default is true.
 * @param cloneHandles      (Optional) Use CloneHandle on value entries with the
 *                          handle data type. The handles will still refer to
 *                          the same data, but through a new cloned handle.
 *                          Default is false.
 *
 * @return                  Reference to new cloned object.
 */
stock Object:ObjLib_CloneObject(Object:objectTemplate, bool:mutableObject = true, bool:cloneHandles = false)

________________________________________________________________________________
/**
 * Returns whether the object reference is valid.
 *
 * @param object    Object reference to validate.
 *
 * @return          True if valid, false otherwise.
 */
stock bool:ObjLib_IsValidObject(Object:object)

________________________________________________________________________________
/**
 * Returns whether the specified object is mutable.
 *
 * @return      True if mutable, false otherwise.
 */
stock bool:ObjLib_IsMutable(Object:object)

________________________________________________________________________________
/**
 * Gets a value of type "any" from the specified key.
 *
 * @param object    Object to get value from.
 * @param keyName   Name of key. Case sensitive.
 *
 * @return          Value in the specified key.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock any:ObjLib_GetAny(Object:object, const String:keyName[])

________________________________________________________________________________
/**
 * Sets a value of type "any" in the specified key.
 *
 * @param object    Object to update.
 * @param keyName   Name of key. Case sensitive.
 * @param value     Value to set.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock ObjLib_SetAny(Object:object, const String:keyName[], any:value)

________________________________________________________________________________
/**
 * Gets a value of type "cell" from the specified key.
 *
 * @param object    Object to get value from.
 * @param keyName   Name of key. Case sensitive.
 *
 * @return          Value in the specified key.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock ObjLib_GetCell(Object:object, const String:keyName[])

________________________________________________________________________________
/**
 * Sets a value of type "cell" in the specified key.
 *
 * @param object    Object to update.
 * @param keyName   Name of key. Case sensitive.
 * @param value     Value to set.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock ObjLib_SetCell(Object:object, const String:keyName[], any:value)

________________________________________________________________________________
/**
 * Gets a value of type "bool" from the specified key.
 *
 * @param object    Object to get value from.
 * @param keyName   Name of key. Case sensitive.
 *
 * @return          Value in the specified key.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock bool:ObjLib_GetBool(Object:object, const String:keyName[])

________________________________________________________________________________
/**
 * Sets a value of type "bool" in the specified key.
 *
 * @param object    Object to update.
 * @param keyName   Name of key. Case sensitive.
 * @param value     Value to set.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock ObjLib_SetBool(Object:object, const String:keyName[], bool:value)

________________________________________________________________________________
/**
 * Gets a value of type "float" from the specified key.
 *
 * @param object    Object to get value from.
 * @param keyName   Name of key. Case sensitive.
 *
 * @return          Value in the specified key.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock Float:ObjLib_GetFloat(Object:object, const String:keyName[])

________________________________________________________________________________
/**
 * Sets a value of type "float" in the specified key.
 *
 * @param object    Object to update.
 * @param keyName   Name of key. Case sensitive.
 * @param value     Value to set.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock ObjLib_SetFloat(Object:object, const String:keyName[], Float:value)

________________________________________________________________________________
/**
 * Gets a value of type "handle" from the specified key.
 *
 * @param object    Object to get value from.
 * @param keyName   Name of key. Case sensitive.
 *
 * @return          Value in the specified key.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock Handle:ObjLib_GetHandle(Object:object, const String:keyName[])

________________________________________________________________________________
/**
 * Sets a value of type "handle" in the specified key.
 *
 * @param object    Object to update.
 * @param keyName   Name of key. Case sensitive.
 * @param value     Value to set.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock ObjLib_SetHandle(Object:object, const String:keyName[], Handle:value)

________________________________________________________________________________
/**
 * Gets a value of type "function" from the specified key.
 *
 * @param object    Object to get value from.
 * @param keyName   Name of key. Case sensitive.
 *
 * @return          Value in the specified key.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock Function:ObjLib_GetFunction(Object:object, const String:keyName[])

________________________________________________________________________________
/**
 * Sets a value of type "function" in the specified key.
 *
 * @param object    Object to update.
 * @param keyName   Name of key. Case sensitive.
 * @param value     Value to set.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock ObjLib_SetFunction(Object:object, const String:keyName[], Function:value)

________________________________________________________________________________
/**
 * Gets a value of type "array" in the specified key.
 *
 * @param object    Object to get value from.
 * @param keyName   Name of key. Case sensitive.
 * @param buffer    Destination buffer.
 * @param maxlen    Size of buffer.
 *
 * @return          Number of cells copied.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock ObjLib_GetArray(Object:object, const String:keyName[], any:buffer[], maxlen)

________________________________________________________________________________
/**
 * Sets a value of type "array" in the specified key.
 *
 * @param object    Object to update.
 * @param keyName   Name of key. Case sensitive.
 * @param values    Array to set.
 * @param maxlen    Size of array.
 *
 * @return          Number of cells copied.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock ObjLib_SetArray(Object:object, const String:keyName[], const any:values[], maxlen)

________________________________________________________________________________
/**
 * Gets a value of type "string" in the specified key.
 *
 * @param object    Object to get value from.
 * @param keyName   Name of key. Case sensitive.
 * @param buffer    Destination buffer.
 * @param maxlen    Size of buffer.
 *
 * @return          Number of characters copied.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock ObjLib_GetString(Object:object, const String:keyName[], String:buffer[], maxlen)

________________________________________________________________________________
/**
 * Sets a value of type "string" in the specified key.
 *
 * @param object    Object to update.
 * @param keyName   Name of key. Case sensitive.
 * @param value     String to set.
 *
 * @return          Number of characters copied.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock ObjLib_SetString(Object:object, const String:keyName[], const String:value[])

________________________________________________________________________________
/**
 * Gets a value of type "object" from the specified key.
 *
 * @param object    Object to get value from.
 * @param keyName   Name of key. Case sensitive.
 *
 * @return          Value in the specified key.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock Object:ObjLib_GetObject(Object:object, const String:keyName[])

________________________________________________________________________________
/**
 * Sets a value of type "object" in the specified key.
 *
 * @param object    Object to update.
 * @param keyName   Name of key. Case sensitive.
 * @param value     Value to set.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock ObjLib_SetObject(Object:object, const String:keyName[], Object:value)

________________________________________________________________________________
/**
 * Gets a value of type "object type" from the specified key.
 *
 * @param object    Object to get value from.
 * @param keyName   Name of key. Case sensitive.
 *
 * @return          Value in the specified key.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock ObjectType:ObjLib_GetObjectType(Object:object, const String:keyName[])

________________________________________________________________________________
/**
 * Sets a value of type "object type" in the specified key.
 *
 * @param object    Object to update.
 * @param keyName   Name of key. Case sensitive.
 * @param value     Value to set.
 *
 * @error           Invalid object, key name or key type mismatch.
 */
stock ObjLib_SetObjectType(Object:object, const String:keyName[], ObjectType:value)

________________________________________________________________________________
/**
 * Gets a value of type "any" at the specified key index.
 *
 * @param object    Object to get value from.
 * @param index     Index of key.
 *
 * @return          Value in the specified key.
 *
 * @error           Invalid object, key index or key type mismatch.
 */
stock any:ObjLib_GetAnyAt(Object:object, index)

________________________________________________________________________________
/**
 * Sets a value of type "any" at the specified key index.
 *
 * @param object    Object to update.
 * @param index     Index of key.
 * @param value     Value to set.
 */
stock ObjLib_SetAnyAt(Object:object, index, any:value)

________________________________________________________________________________
/**
 * Gets a value of type "cell" at the specified key index.
 *
 * @param object    Object to get value from.
 * @param index     Index of key.
 *
 * @return          Value in the specified key.
 *
 * @error           Invalid object, key index or key type mismatch.
 */
stock ObjLib_GetCellAt(Object:object, index)

________________________________________________________________________________
/**
 * Sets a value of type "cell" at the specified key index.
 *
 * @param object    Object to update.
 * @param index     Index of key.
 * @param value     Value to set.
 */
stock ObjLib_SetCellAt(Object:object, index, value)

________________________________________________________________________________
/**
 * Gets a value of type "bool" at the specified key index.
 *
 * @param object    Object to get value from.
 * @param index     Index of key.
 *
 * @return          Value in the specified key.
 *
 * @error           Invalid object, key index or key type mismatch.
 */
stock bool:ObjLib_GetBoolAt(Object:object, index)

________________________________________________________________________________
/**
 * Sets a value of type "bool" at the specified key index.
 *
 * @param object    Object to update.
 * @param index     Index of key.
 * @param value     Value to set.
 */
stock ObjLib_SetBoolAt(Object:object, index, bool:value)

________________________________________________________________________________
/**
 * Gets a value of type "float" at the specified key index.
 *
 * @param object    Object to get value from.
 * @param index     Index of key.
 *
 * @return          Value in the specified key.
 *
 * @error           Invalid object, key index or key type mismatch.
 */
stock Float:ObjLib_GetFloatAt(Object:object, index)

________________________________________________________________________________
/**
 * Sets a value of type "float" at the specified key index.
 *
 * @param object    Object to update.
 * @param index     Index of key.
 * @param value     Value to set.
 */
stock ObjLib_SetFloatAt(Object:object, index, Float:value)

________________________________________________________________________________
/**
 * Gets a value of type "handle" at the specified key index.
 *
 * @param object    Object to get value from.
 * @param index     Index of key.
 *
 * @return          Value in the specified key.
 *
 * @error           Invalid object, key index or key type mismatch.
 */
stock Handle:ObjLib_GetHandleAt(Object:object, index)

________________________________________________________________________________
/**
 * Sets a value of type "handle" at the specified key index.
 *
 * @param object    Object to update.
 * @param index     Index of key.
 * @param value     Value to set.
 */
stock ObjLib_SetHandleAt(Object:object, index, Handle:value)

________________________________________________________________________________
/**
 * Gets a value of type "function" at the specified key index.
 *
 * @param object    Object to get value from.
 * @param index     Index of key.
 *
 * @return          Value in the specified key.
 *
 * @error           Invalid object, key index or key type mismatch.
 */
stock Function:ObjLib_GetFunctionAt(Object:object, index)

________________________________________________________________________________
/**
 * Sets a value of type "function" at the specified key index.
 *
 * @param object    Object to update.
 * @param index     Index of key.
 * @param value     Value to set.
 */
stock ObjLib_SetFunctionAt(Object:object, index, Function:value)

________________________________________________________________________________
/**
 * Gets a value of type "array" at the specified key index.
 *
 * @param object    Object to get value from.
 * @param index     Index of key.
 * @param buffer    Destination buffer.
 * @param maxlen    Size of buffer.
 *
 * @return          Number of cells copied.
 *
 * @error           Invalid object, key index or key type mismatch.
 */
stock ObjLib_GetArrayAt(Object:object, index, any:buffer[], maxlen)

________________________________________________________________________________
/**
 * Sets a value of type "array" at the specified key index.
 *
 * @param object    Object to update.
 * @param index     Index of key.
 * @param values    Array to set.
 * @param maxlen    Size of array.
 *
 * @return          Number of cells copied.
 */
stock ObjLib_SetArrayAt(Object:object, index, const any:values[], maxlen)

________________________________________________________________________________
/**
 * Gets a value of type "string" at the specified key index.
 *
 * @param object    Object to get value from.
 * @param index     Index of key.
 * @param buffer    Destination buffer.
 * @param maxlen    Size of buffer.
 *
 * @return          Number of characters copied.
 *
 * @error           Invalid object, key index or key type mismatch.
 */
stock ObjLib_GetStringAt(Object:object, index, String:buffer[], maxlen)

________________________________________________________________________________
/**
 * Sets a value of type "string" at the specified key index.
 *
 * @param object    Object to update.
 * @param index     Index of key.
 * @param value     String to set.
 *
 * @return          Number of characters copied.
 */
stock ObjLib_SetStringAt(Object:object, index, const String:value[])

________________________________________________________________________________
/**
 * Gets a value of type "object" at the specified key index.
 *
 * @param object    Object to get value from.
 * @param index     Index of key.
 *
 * @return          Value in the specified key.
 *
 * @error           Invalid object, key index or key type mismatch.
 */
stock Object:ObjLib_GetObjectAt(Object:object, index)

________________________________________________________________________________
/**
 * Sets a value of type "object" at the specified key index.
 *
 * @param object    Object to update.
 * @param index     Index of key.
 * @param value     Value to set.
 */
stock ObjLib_SetObjectAt(Object:object, index, Object:value)

________________________________________________________________________________
/**
 * Gets a value of type "object type" at the specified key index.
 *
 * @param object    Object to get value from.
 * @param index     Index of key.
 *
 * @return          Value in the specified key.
 *
 * @error           Invalid object, key index or key type mismatch.
 */
stock ObjectType:ObjLib_GetObjectTypeAt(Object:object, index)

________________________________________________________________________________
/**
 * Sets a value of type "object type" at the specified key index.
 *
 * @param object    Object to update.
 * @param index     Index of key.
 * @param value     Value to set.
 */
stock ObjLib_SetObjectTypeAt(Object:object, index, ObjectType:value)

________________________________________________________________________________
/**
 * Gets an object's type descriptor.
 *
 * @param object    Object to get type from.
 *
 * @return          Object type descriptor reference.
 */
stock ObjectType:ObjLib_GetTypeDescriptor(Object:object)

________________________________________________________________________________
/**
 * Gets the index for the specified key in an object.
 *
 * @param object    Object to get index from.
 * @param keyName   Name of key. Case sensitive.
 *
 * @return          Key index if successful, or -1 if it doesn't exist.
 */
stock ObjLib_GetKeyIndex(Object:object, const String:keyName[])

________________________________________________________________________________
/**
 * Returns whether the specified object type descriptor is mutable (not locked).
 *
 * @return      True if mutable, false otherwise.
 */
stock bool:ObjLib_IsTypeMutable(ObjectType:typeDescriptor)

________________________________________________________________________________
/**
 * Returns the name of a data type.
 *
 * @param dataType  Data type value.
 * @param buffer    Name buffer.
 * @param maxlen    Size of buffer.
 *
 * @return          Number of cells written.
 */
stock ObjLib_DataTypeToString(ObjectDataType:dataType, String:buffer[], maxlen)

________________________________________________________________________________
/**
 * Gets the list of key names in an object type descriptor.
 *
 * @param typeDescriptor    Object type to inspect.
 *
 * @return      Handle to ADT array with strings of key names. Do not close this
 *              handle. Use ObjLib_DeleteType instead.
 */
stock Handle:ObjLib_GetTypeKeys(ObjectType:typeDescriptor)

________________________________________________________________________________
/**
 * Gets the list of data types for each key in an object type descriptor.
 *
 * @param typeDescriptor    Type descriptor to inspect.
 *
 * @return      Handle to ADT array of ObjectDataType entries.
 */
stock Handle:ObjLib_GetTypeDataTypes(ObjectType:typeDescriptor)
