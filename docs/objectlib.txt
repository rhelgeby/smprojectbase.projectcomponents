Object Library
==============

MAIN FEATURES
-------------

* Key/value object storage manager
  Create objects with dynamic content. Data is internally stored in ADT Arrays.

  Object data can be accessed through get/set functions (which implies
  validation).

* Mutable or immutable objects
  Objects can be either mutable or immutable. Immutable objects can't modify
  their type (add/remove keys) when created, but data in existing keys can be
  modified.
  
  Both use a type descriptor as a template. Mutable objects store a bundled
  descriptor so they can be modified independently, while immutable objects
  store a reference to a shared read-only type descriptor.

* Supports built-in and custom data validation
  The library supports basic validation constraints such as min/max limits in
  addition to a forward where the user can do custom validation of the object.

* Type safe (as far as it's possible in SourcePawn)
  Each key is assigned a type. This structure requires you to use appropriate
  get/set functions where the library will check if you use the correct
  function at runtime - and the compiler will be able to do tag checks.

* Import (and validate) data from Valve KeyValue files
  Creates objects based on the contents of a KeyValue file, and a user defined
  object type descriptor with optional validation constraints.

* Reflection
  Objects or types can be inspected at run time. Loop through keys, get data
  types or validation constraints.


WHAT IT DOESN'T DO
------------------

* Memory management
  You'll have to make sure objects and types are deleted when no longer in use.
  Otherwise there will be memory leaks. Read the API documentation carefully.

* It's not a tree structure
  Regular KeyValue files use a tree structure. This object manager use a plain
  associative array structure where each object has keys mapped to values.
  
  However, a tree structure is indirectly supported by linking object references
  together. Objects can store references to other objects. It has its own object
  data type so that the compiler can do tag checking on object references as
  well.


RESOURCE USAGE
--------------

* Small CPU overhead
  The main goal isn't a super efficient object manager, but efficient enough.
  Because of type checking and validation there is a small overhead when
  modifying data. These checks are basically comparision of primitive values and
  shouldn't be an issue with normal usage.
  
  Another overhead is the native call overhead for reading and writing to ADT
  array. This overhead is so tiny it shouldn't be mentioned, but it's still
  there.

  If you have code that's _very_ busy you should consider using buffers or
  caches in front of the data storage. Use the SourceMod profiler to measure if
  this really is an issue in your code before optimizing.

* Memory overhead
  Since it's a dynamic storage manager, objects need to store meta data and will
  use a little bit more memory than a static hard coded solution would. But it's
  also a lot more flexible solution.

  However, immutable objects are more memory efficient than mutable objects,
  since immutable objects share their type descriptor between objects of the
  same type. Mutable objects have each their own type descriptor.
  
  Use immutable objects when you can to reduce memory overhead, especially on
  object types that aren't modified after creation.

* A little memory and CPU overhead is a trade off for writing more code
  yourself. It can still be efficient if used correctly.
